const questionElement = document.getElementById('question');
const options = document.querySelectorAll('.option');
const scoreElement = document.getElementById('score');
const correctAnswersElement = document.getElementById('correct-answers');
const currentQuestionElement = document.getElementById('current-question');
const totalQuestionsElement = document.getElementById('total-questions');

let currentQuestion = 0;
let score = 0;
let correctAnswers = 0;
let hasAnswered = false;

let moneyLadder = [
    {
        question: 'What is a prompt in the context of AI (for example ChatGPT)?',
        options: ['A: A command that tells an AI to stop its operation.', 'B: A set of instructions or a question given to an AI to generate a response.', 'C: A technical error message displayed by the AI system.', 'D: A type of data used to train an AI model.'],
        correct: 1
    },
    {
        question: 'Which of the following is an example of a prompt?',
        options: ['A: Explain the water cycle.', 'B: The water cycle is important.', 'C: Water evaporates into clouds.', 'D: Clouds are white and fluffy.'],
        correct: 0
    },
    {
        question: 'Which of the following prompts is better for generating a specific and detailed response from an AI?',
        options: ['A: Tell me about climate change.', 'B: Describe how human activities contribute to climate change through carbon emissions and how it impacts global temperatures.', 'C: What do you know about the weather?', 'D: Write something about the environment.'],
        correct: 1
    },
    {
        question: "In which year was OpenAI's ChatGPT first released to the public?",
        options: ['A: 2019', 'B: 2020', 'C: 2021', 'D: 2022'],
        correct: 3
    },
    {
        question: 'What is iterative prompting?',
        options: ['A: Repeatedly asking the same question until the AI gives the correct answer.', 'B: A method where prompts are refined and repeated using previous responses to ask follow-up questions for more detailed or accurate results.', 'C: Asking multiple questions in a single prompt to get a longer response.', 'D: Using random prompts to test AI\'s flexibility.'],
        correct: 1
    },
    {
        question: 'Which of the following is an advanced prompting technique designed to improve reliability and performance of LLMs?',
        options: ['A: Zero-shot Prompting', 'B: Random Prompting', 'C: Passive Prompting', 'D: Disconnected Prompting'],
        correct: 0
    },
    {
        question: 'Which technique is used to improve a model\'s performance by providing demonstrations or examples in the prompt to guide the model?',
        options: ['A: Zero-shot Prompting', 'B: Few-shot Prompting', 'C: Chain-of-Thought Prompting', 'D: Random Labeling'],
        correct: 1
    },
    {
        question: 'What is the key feature of Automatic Reasoning and Tool-use (ART) when applied to large language models?',
        options: ['A: It requires no demonstrations for multi-step reasoning.', 'B: It integrates external tool outputs during task generation.', 'C: It performs tasks without any pauses or tool use.', 'D: It is designed specifically for single-step tasks only.'],
        correct: 1
    },
    {
        question: 'What is the main purpose of Directional Stimulus Prompting (DSP) in large language models (LLMs)?',
        options: ['A: To simplify the model\'s architecture by removing hints.', 'B: To optimize model outputs through random stimuli.', 'C: To guide a frozen LLM using hints generated by a smaller policy model.', 'D: To improve zero-shot learning without any external input.'],
        correct: 2
    },
    {
        question: 'What is the key advancement of Multimodal CoT Prompting compared to traditional chain-of-thought (CoT) prompting?',
        options: ['A: It eliminates the need for rationale generation.', 'B: It incorporates both text and vision modalities in reasoning.', 'C: It reduces the number of reasoning steps required.', 'D: It focuses exclusively on language processing.'],
        correct: 1
    }
];

totalQuestionsElement.textContent = moneyLadder.length;

function loadQuestion() {
    let questionData = moneyLadder[currentQuestion];
    questionElement.textContent = questionData.question;

    options.forEach((option, index) => {
        option.textContent = questionData.options[index];
        option.dataset.answer = index === questionData.correct ? 'correct' : 'wrong';
    });

    hasAnswered = false; // Reset the answer status for the new question
}

options.forEach(option => {
    option.addEventListener('click', (event) => {

        if (event.target.dataset.answer === 'correct') {
            event.target.classList.add('correct-animation');
            setTimeout(() => {
                event.target.classList.remove('correct-animation');

                // Update score and proceed to the next question only if not previously answered wrong
                if (!hasAnswered) {
                    score += 100;  // Increment score by 100 for each correct answer
                    correctAnswers++;
                    correctAnswersElement.textContent = correctAnswers;
                    scoreElement.textContent = score;
                    hasAnswered = true; // Mark as answered after the first attempt
                }

                currentQuestion++;
                if (currentQuestion < moneyLadder.length) {
                    loadQuestion();
                    currentQuestionElement.textContent = currentQuestion + 1;
                } else {
                    alert('Congratulations! You completed the quiz.');
                    resetGame();
                }
            }, 1000);
        } else {
            event.target.classList.add('wrong-animation');
            setTimeout(() => {
                event.target.classList.remove('wrong-animation');
                hasAnswered = true; // Mark as answered after the first attempt
            }, 1000);
        }
    });
});

function resetGame() {
    currentQuestion = 0;
    score = 0;
    correctAnswers = 0; // Reset correct answers count
    loadQuestion();
    correctAnswersElement.textContent = correctAnswers;
    scoreElement.textContent = score;
    currentQuestionElement.textContent = 1;
}

loadQuestion();